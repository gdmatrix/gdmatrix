/*
 * GDMatrix
 *
 * Copyright (C) 2020, Ajuntament de Sant Feliu de Llobregat
 *
 * This program is licensed and may be used, modified and redistributed under
 * the terms of the European Public License (EUPL), either version 1.1 or (at
 * your option) any later version as soon as they are approved by the European
 * Commission.
 *
 * Alternatively, you may redistribute and/or modify this program under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either  version 3 of the License, or (at your option)
 * any later version.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the licenses for the specific language governing permissions, limitations
 * and more details.
 *
 * You should have received a copy of the EUPL1.1 and the LGPLv3 licenses along
 * with this program; if not, you may find them at:
 *
 * https://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 * http://www.gnu.org/licenses/
 * and
 * https://www.gnu.org/licenses/lgpl.txt
 */
package org.santfeliu.form.builder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import static org.matrix.dic.DictionaryConstants.EXECUTE_ACTION;
import static org.matrix.dic.DictionaryConstants.READ_ACTION;
import org.matrix.dic.DictionaryManagerPort;
import org.matrix.dic.DictionaryManagerService;
import org.matrix.dic.EnumType;
import org.matrix.dic.Property;
import org.matrix.dic.PropertyDefinition;
import org.matrix.dic.PropertyType;
import org.matrix.doc.ContentInfo;
import org.matrix.util.WSEndpoint;
import org.santfeliu.dic.Type;
import org.matrix.doc.Document;
import org.matrix.doc.DocumentConstants;
import org.matrix.doc.DocumentFilter;
import org.matrix.doc.OrderByProperty;
import org.matrix.security.AccessControl;
import org.matrix.util.WSDirectory;
import org.santfeliu.dic.TypeCache;
import org.santfeliu.dic.util.DictionaryUtils;
import org.santfeliu.doc.client.DocumentManagerClient;
import org.santfeliu.form.Field;
import org.santfeliu.form.Form;
import org.santfeliu.form.FormDescriptor;
import org.santfeliu.form.View;
import org.santfeliu.form.type.html.HtmlField;
import org.santfeliu.form.type.html.HtmlForm;
import org.santfeliu.form.type.html.HtmlSelectView;
import org.santfeliu.form.type.html.HtmlView;
import org.santfeliu.security.User;
import org.santfeliu.security.UserCache;

/**
 *
 * @author realor
 */
public class TypeFormBuilder extends MatrixFormBuilder
{
  public static final String PREFIX = "type";
  public static final String SEARCH_PREFIX = "searchtype";
  public static final String VIEW_PREFIX = "viewtype";
  public static final String USERID = "&userid=";
  public static final String PASSWORD = "&password=";
  public static final String TYPE_PROPERTY = "typeId";
  public static final String SEARCH_TYPE_PROPERTY = "searchTypeId";
  public static final String VIEW_TYPE_PROPERTY = "viewTypeId";
  public static final String AUTOMATIC_FORM_PROPERTY = "_automaticFormEnabled";
  public static final String AUTOMATIC_SEARCH_FORM_PROPERTY =
    "_automaticSearchFormEnabled";
  public static final String AUTOMATIC_VIEW_FORM_PROPERTY =
    "_automaticViewFormEnabled";
  public static final int LABEL_COLUMN_WIDTH = 19; // percentage
  private static final String SORT_FORMS_BY_TYPE_DEPTH_PROPERTY =
    "_sortFormsByTypeDepth";
  private static final String VARIANT_SEPARATOR = "@";

  public static enum FormMode
  {
    EDIT,
    SEARCH,
    VIEW
  }

  @Override
  public List<FormDescriptor> findForms(String selector)
  {
    SelectorParser parser = new SelectorParser(selector);
    Type type = parser.getType();
    if (type != null)
    {
      try
      {
        List<FormDescriptor> descriptors = new ArrayList();
        boolean sortDescending = "desc".equals(getSortFormsByTypeDepth(type));
        addUserForms(type, descriptors, parser, sortDescending);
        if (sortDescending)
        {
          Collections.reverse(descriptors);
        }

        addAutoForm(type, parser.getFormMode(), descriptors);

        return descriptors;
      }
      catch (Exception ex)
      {
      }
    }
    return Collections.EMPTY_LIST;
  }

  @Override
  public Form getForm(String selector)
  {
    SelectorParser parser = new SelectorParser(selector);
    Type type = parser.getType();
    if (type != null)
    {
      return createForm(type, parser.getFormMode());
    }
    return null;
  }

  protected HtmlForm createForm(Type type, FormMode formMode)
  {
    HtmlForm form = new HtmlForm();
    form.setEncoding("UTF-8");
    form.setTitle("Autogenerated form: " + type.getDescription() +
     " (" + type.getTypeId() + ")");

    HtmlView bodyView = new HtmlView("body", View.GROUP);
    HtmlView tableView = new HtmlView("table", View.GROUP);
    tableView.setProperty("style", "width:100%;border-collapse:collapse");
    bodyView.getChildren().add(tableView);
    form.setRootView(bodyView);

    // add fields to form
    List<PropertyDefinition> pdList =
      type.getPropertyDefinition(false, true, false);
    for (PropertyDefinition pd : pdList)
    {
      addFormField(form, formMode, tableView, pd);
    }
    return form;
  }

  protected void addFormField(HtmlForm form, FormMode formMode,
    HtmlView tableView, PropertyDefinition property)
  {
    if (!property.isHidden())
    {
      // create field
      HtmlField field = new HtmlField();
      field.setReference(property.getName());
      field.setLabel(property.getDescription());
      field.setMinOccurs(formMode.equals(FormMode.SEARCH) ? 0 :
        property.getMinOccurs());
      field.setMaxOccurs(property.getMaxOccurs());
      if (!formMode.equals(FormMode.SEARCH))
        field.setReadOnly(property.isReadOnly());
      form.addField(field);

      // create view
      HtmlView rowView = new HtmlView("tr", View.GROUP);
      tableView.getChildren().add(rowView);

      HtmlView col1View = new HtmlView("td", View.GROUP);
      rowView.getChildren().add(col1View);
      HtmlView labelView = new HtmlView("#text", View.TEXT);
      col1View.getChildren().add(labelView);
      col1View.setProperty("style", "width:" + LABEL_COLUMN_WIDTH + "%");
      String label = field.getLabel();
      if (!label.endsWith(":")) label += ":";
      labelView.setProperty("text", label);

      HtmlView col2View = new HtmlView("td", View.GROUP);
      rowView.getChildren().add(col2View);
      int valueColumnWidth = 100 - LABEL_COLUMN_WIDTH;
      col2View.setProperty("style", "width:" + valueColumnWidth + "%");

      HtmlView inputView = null;

      String enumTypeId = property.getEnumTypeId();
      if (enumTypeId != null) // enum type property
      {
        EnumType enumType = getEnumType(enumTypeId);
        switch (enumType.getItemType())
        {
          case TEXT: field.setType(Field.TEXT); break;
          case NUMERIC: field.setType(Field.NUMBER); break;
          case BOOLEAN: field.setType(Field.BOOLEAN); break;
          case DATE: field.setType(Field.DATE); break;
        }
        inputView = new HtmlSelectView();
        inputView.setNativeViewType("select");
        inputView.setProperty("dataref", "enumtype:" + enumTypeId);
        if (property.getMaxOccurs() != 1) // multi-valued field
        {
          inputView.setProperty("multiple", "true");
          inputView.setProperty("renderer", "checkBoxList");
          inputView.setProperty("size", "4");
          inputView.setProperty("class", field.isReadOnly() ?
            "readOnlySelectBox" : "selectBox inline");
        }
        else // single-value field
        {
          inputView.setProperty("class", field.isReadOnly() ?
            "readOnlySelectBox" : "selectBox");
          if (formMode.equals(FormMode.SEARCH) || property.getMinOccurs() == 0) // single-value
          {
            // add empty value (NULL)
            HtmlView option = createSelectOption("", "");
            inputView.getChildren().add(option);
          }
        }
      }
      else if (property.getType() == PropertyType.TEXT)
      {
        field.setType(Field.TEXT);
        inputView = new HtmlView("input", View.TEXTFIELD);
        inputView.setProperty("type", "text");
        int size = property.getSize();
        if (size > 0)
        {
          inputView.setProperty("size", String.valueOf(Math.min(size, 70)));
          inputView.setProperty("maxlength", String.valueOf(size));
        }
        else
        {
          inputView.setProperty("size", "70");
        }
        inputView.setProperty("class", "inputBox");
        if (!property.getValue().isEmpty())
        {
          inputView.setProperty("value", property.getValue().get(0));
        }
      }
      else if (property.getType() == PropertyType.NUMERIC)
      {
        field.setType(Field.NUMBER);
        inputView = new HtmlView("input", View.TEXTFIELD);
        inputView.setProperty("type", "text");
        inputView.setProperty("style", "width:100px");
        inputView.setProperty("class", "inputBox");
        if (!property.getValue().isEmpty())
        {
          inputView.setProperty("value", property.getValue().get(0));
        }
      }
      else if (property.getType() == PropertyType.BOOLEAN)
      {
        field.setType(Field.BOOLEAN);
        if (field.getMinOccurs() == 0 || formMode.equals(FormMode.SEARCH)) // draw select [NULL/T/F]
        {
          inputView = new HtmlView("select", View.SELECT);
          inputView.setProperty("class", "selectBox");
          HtmlView option1 = createSelectOption("", "");
          HtmlView option2 = createSelectOption("true", "TRUE");
          HtmlView option3 = createSelectOption("false", "FALSE");
          inputView.getChildren().add(option1);
          inputView.getChildren().add(option2);
          inputView.getChildren().add(option3);
          if (!property.getValue().isEmpty())
          {
            String value = property.getValue().get(0);
            if ("true".equals(value))
            {
              option2.setProperty("selected", "selected");
            }
            else if ("false".equals(value))
            {
              option3.setProperty("selected", "selected");
            }
          }
        }
        else // field is not nullable, paint as checkbox
        {
          inputView = new HtmlView("input", View.TEXTFIELD);
          inputView.setProperty("type", "checkbox");
          if (!property.getValue().isEmpty())
          {
            if ("true".equals(property.getValue().get(0)))
            {
              inputView.setProperty("checked", "true");
            }
          }
        }
      }
      else if (property.getType() == PropertyType.DATE)
      {
        field.setType(Field.DATE);
        inputView = new HtmlView("input", View.TEXTFIELD);
        inputView.setProperty("type", "text");
        inputView.setProperty("format", "date");
        inputView.setProperty("style", "width:100px");
        inputView.setProperty("class", "inputBox");
        if (!property.getValue().isEmpty())
        {
          inputView.setProperty("value", property.getValue().get(0));
        }
      }
      if (inputView != null)
      {
        inputView.setProperty("name", field.getReference());
        inputView.setReference(field.getReference());
        if (field.isReadOnly()) inputView.setProperty("disabled", "true");
        col2View.getChildren().add(inputView);
        form.linkView(inputView, field);
      }
    }
  }

  void addUserForms(Type type, List<FormDescriptor> descriptors,
    SelectorParser parser, boolean sortDescending)
    throws Exception
  {
    FormMode formMode = parser.getFormMode();
    DocumentManagerClient docClient = getDocumentManagerClient();
    if (type != null)
    {
      DocumentFilter filter = new DocumentFilter();
      filter.setVersion(0);
      filter.setDocTypeId(FORM_TYPEID);
      Property property = new Property();
      if (null == formMode)
        property.setName(TYPE_PROPERTY);
      else switch (formMode)
      {
        case SEARCH:
          property.setName(SEARCH_TYPE_PROPERTY);
          break;
        case VIEW:
          property.setName(VIEW_TYPE_PROPERTY);
          break;
        default:
          property.setName(TYPE_PROPERTY);
          break;
      }
      property.getValue().add(type.getTypeId());
      filter.getProperty().add(property);

      OrderByProperty orderBy = new OrderByProperty();
      orderBy.setName(DocumentConstants.TITLE);
      orderBy.setDescending(sortDescending);
      filter.getOrderByProperty().add(orderBy);
      List<Document> documents = docClient.findDocuments(filter);

      documents = filterDocumentsByVariant(documents, parser.getVariant());
      
      for (Document document : documents)
      {
        document =
          docClient.loadDocument(document.getDocId(), 0, ContentInfo.ID);
        List<AccessControl> acl = document.getAccessControl();
        User user = UserCache.getUser(parser.getUserId(), parser.getPassword());
        Set<String> roles = user.getRoles();
        String docTypeId = document.getDocTypeId();
        Type docType = TypeCache.getInstance().getType(docTypeId);
        boolean canExecuteForm =
          DictionaryUtils.canPerformAction(EXECUTE_ACTION, roles, acl, docType)
          || DictionaryUtils.canPerformAction(READ_ACTION, roles, acl, docType)
          || roles.contains(DocumentConstants.DOC_ADMIN_ROLE);
        if (canExecuteForm)
        {
          FormDescriptor descriptor = new FormDescriptor();
          String title = document.getTitle();
          int index = title.indexOf(":"); // remove form name.
          if (index != -1)
          {
            title = title.substring(index + 1);
          }
          if (title.length() == 0) title = type.getTypeId();
          descriptor.setTitle(title);
          descriptor.setSelector(
            DocumentFormBuilder.PREFIX + ":" + document.getDocId());
          descriptors.add(descriptor);
        }
      }
      addUserForms(type.getSuperType(), descriptors, parser, sortDescending);
    }
  }
  
  private List<Document> filterDocumentsByVariant(List<Document> documents, 
    String variant)
  {
    List<Document> result = new ArrayList();
    for (Document document : documents)
    {
      String formName = getFormName(document);
      if (variant == null || variant.trim().isEmpty())
      {
        if (!formName.contains(VARIANT_SEPARATOR)) result.add(document);
      }
      else if (formName.endsWith(VARIANT_SEPARATOR + variant))
      {
        result.add(document);
      }
      else if (!formName.contains(VARIANT_SEPARATOR))
      {
        if (!existsDocumentVariant(formName, documents, variant))
        {
          result.add(document);
        }
      }
      else //@other
      {
        //not include
      }
    }
    return result;
  }
  
  private boolean existsDocumentVariant(String baseFormName, 
    List<Document> documents, String variant)
  {
    for (Document document : documents)
    {
      String docFormName = getFormName(document);
      if (docFormName.equals(baseFormName + VARIANT_SEPARATOR + variant)) 
        return true;
    }
    return false;
  }
  
  private String getFormName(Document document)
  {
    String title = document.getTitle();
    if (title.contains(":"))
    {
      return title.substring(0, title.indexOf(":"));
    }
    return title;
  }

  protected void addAutoForm(Type type, FormMode formMode,
    List<FormDescriptor> descriptors)
  {
    boolean automaticEnabled = true;
    String propertyName = AUTOMATIC_FORM_PROPERTY;
    if (FormMode.SEARCH.equals(formMode))
      propertyName = AUTOMATIC_SEARCH_FORM_PROPERTY;
    else if (FormMode.VIEW.equals(formMode))
      propertyName = AUTOMATIC_VIEW_FORM_PROPERTY;

    PropertyDefinition automaticProperty =
      type.getPropertyDefinition(propertyName);
    if (automaticProperty != null)
    {
      if (!automaticProperty.getValue().isEmpty())
      {
        String value = automaticProperty.getValue().get(0);
        automaticEnabled = "true".equalsIgnoreCase(value)
          || ("auto".equalsIgnoreCase(value) && descriptors.isEmpty());
      }
    }
    if (automaticEnabled)
    {
      if (!type.getPropertyDefinition(false, true, false).isEmpty())
      {
        FormDescriptor descriptor = new FormDescriptor();
        descriptor.setTitle("Automatic form for " + type.getTypeId());
        String prefix = FormMode.SEARCH.equals(formMode) ? SEARCH_PREFIX :
          FormMode.VIEW.equals(formMode) ? VIEW_PREFIX : PREFIX;
        descriptor.setSelector(prefix + ":" + type.getTypeId());
        descriptors.add(descriptor);
      }
    }
  }

  protected EnumType getEnumType(String enumTypeId)
  {
    EnumType enumType = null;
    try
    {
      WSDirectory wsDir = WSDirectory.getInstance();
      WSEndpoint endpoint = wsDir.getEndpoint(DictionaryManagerService.class);
      DictionaryManagerPort port =
        endpoint.getPort(DictionaryManagerPort.class);
      return port.loadEnumType(enumTypeId);
    }
    catch (Exception ex)
    {
    }
    return enumType;
  }

  private HtmlView createSelectOption(String value, String label)
  {
    HtmlView option = new HtmlView();
    option.setNativeViewType("option");
    option.setViewType(View.ITEM);
    option.setProperty("value", value);
    HtmlView optionValue = new HtmlView();
    optionValue.setNativeViewType("#text");
    optionValue.setViewType(View.TEXT);
    optionValue.setProperty("text", label);
    option.getChildren().add(optionValue);
    return option;
  }

  private String getSortFormsByTypeDepth(Type type)
  {
    String value = null;
    if (type != null)
    {
      PropertyDefinition pd =
        type.getPropertyDefinition(SORT_FORMS_BY_TYPE_DEPTH_PROPERTY);
      if (pd != null && !pd.getValue().isEmpty())
      {
        value = (String)pd.getValue().get(0);
      }
    }
    return ("asc".equals(value) ? "asc" : "desc");
  }

  class SelectorParser
  {
    private String typeId;
    private String userId;
    private String password;
    private FormMode formMode;
    private String variant;

    SelectorParser(String selector)
    {
      String prefix = null;
      if (selector.startsWith(PREFIX + ":") || 
        selector.startsWith(PREFIX + VARIANT_SEPARATOR))
      {
        prefix = selector.substring(0, selector.indexOf(":"));
        formMode = FormMode.EDIT;
      }
      else if (selector.startsWith(SEARCH_PREFIX + ":") || 
        selector.startsWith(SEARCH_PREFIX + VARIANT_SEPARATOR))
      {
        prefix = selector.substring(0, selector.indexOf(":"));
        formMode = FormMode.SEARCH;
      }
      else if (selector.startsWith(VIEW_PREFIX + ":") || 
        selector.startsWith(VIEW_PREFIX + VARIANT_SEPARATOR))
      {
        prefix = selector.substring(0, selector.indexOf(":"));
        formMode = FormMode.VIEW;
      }
      if (prefix != null)
      {
        if (prefix.contains(VARIANT_SEPARATOR))
        {
          variant = prefix.substring(prefix.indexOf(VARIANT_SEPARATOR) + 1);
        }
        typeId = extract(selector.substring(prefix.length() + 1), null, USERID);
        userId = extract(selector, USERID, PASSWORD);
        password = extract(selector, PASSWORD, null);
      }
    }

    public String getTypeId()
    {
      return typeId;
    }

    public Type getType()
    {
      if (typeId == null) return null;
      TypeCache typeCache = TypeCache.getInstance();
      return typeCache.getType(typeId);
    }

    public String getUserId()
    {
      return userId;
    }

    public String getPassword()
    {
      return password;
    }

    public FormMode getFormMode()
    {
      return formMode;
    }

    public String getVariant()
    {
      return variant;
    }

    private String extract(String selector, String startToken, String endToken)
    {
      String value = null;
      int index;
      if (startToken == null)
      {
        index = 0;
        value = selector;
      }
      else
      {
        index = selector.indexOf(startToken);
        if (index != -1)
        {
          value = selector.substring(index + startToken.length());
        }
      }
      if (value != null)
      {
        if (endToken != null)
        {
          int index2 = value.indexOf(endToken);
          if (index2 != -1)
          {
            value = value.substring(0, index2);
          }
        }
      }
      return value;
    }
  }
}
