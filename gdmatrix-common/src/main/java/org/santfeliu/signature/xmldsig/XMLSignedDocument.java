/*
 * GDMatrix
 *
 * Copyright (C) 2020, Ajuntament de Sant Feliu de Llobregat
 *
 * This program is licensed and may be used, modified and redistributed under
 * the terms of the European Public License (EUPL), either version 1.1 or (at
 * your option) any later version as soon as they are approved by the European
 * Commission.
 *
 * Alternatively, you may redistribute and/or modify this program under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either  version 3 of the License, or (at your option)
 * any later version.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the licenses for the specific language governing permissions, limitations
 * and more details.
 *
 * You should have received a copy of the EUPL1.1 and the LGPLv3 licenses along
 * with this program; if not, you may find them at:
 *
 * https://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 * http://www.gnu.org/licenses/
 * and
 * https://www.gnu.org/licenses/lgpl.txt
 */
package org.santfeliu.signature.xmldsig;

import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.security.PublicKey;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.xml.security.algorithms.MessageDigestAlgorithm;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.keys.content.X509Data;
import org.apache.xml.security.signature.ObjectContainer;
import org.apache.xml.security.signature.Reference;
import org.apache.xml.security.signature.SignedInfo;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.signature.XMLSignatureInput;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.DigesterOutputStream;
import org.apache.xml.security.utils.XMLUtils;
import org.apache.xml.security.utils.resolver.ResourceResolver;
import org.matrix.signature.DataHash;
import org.santfeliu.security.SecurityProvider;
import org.santfeliu.security.util.SecurityUtils;
import org.santfeliu.signature.SignedDocument;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.x509.CRLNumber;
import org.santfeliu.signature.certificate.CACertificateStore;
import org.santfeliu.util.MatrixConfig;
import org.matrix.signature.DocumentValidation;
import org.matrix.signature.SignatureValidation;
import org.w3c.dom.Attr;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.tsp.TimeStampToken;
import org.bouncycastle.util.Store;
import org.matrix.signature.ValidationDetail;
import org.santfeliu.security.util.TimeStampService;
import org.santfeliu.util.TextUtils;
import static org.apache.xml.security.algorithms.MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA1;
import static org.apache.xml.security.algorithms.MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA256;

/**
 *
 * @author realor
 */

/*
  XMLSignedDocument versions:

  1.0 (2007):
    - Signatures are based on XAdES-T version 1.2.2.
    - Contains references to elements outside the ds:Signature.
    - Signatures include an oasis XMLTimeStamp generated by PSIS service
      (urn:oasis:names:tc:dss:1.0:core:schema).
    - Hash algorithm: SHA-1
    - Signature algorithm: SHA1withRSA

  1.1 (2017):
    - Support for external signatures (generated by VALID service).
    - All references point to ds:Object elements.

  1.2 (JAN 2022):
    - Hash algorithm upgraded to: SHA-256.

  1.3 (OCT 2022):
    - Signatures are based on XAdES-T version 1.3.2.
    - XMLTimeStamps replaced by EncapsulatedTimeStamps
    - Signature algorithm upgraded to SHA256withRSA.
    - Suport for LTV (extension to XAdES-A).
    - ArchiveTimeStamps are based on XAdES 1.4.1 specification.

   Signatures of a SignedDocument can be validated with the EU DSS validator:
   https://ec.europa.eu/digital-building-blocks/DSS/webapp-demo

*/

public class XMLSignedDocument implements SignedDocument
{
  static final Logger LOGGER = Logger.getLogger("XMLSignedDocument");

  private Document doc;
  private Element root;
  private String BaseURI;
  private final List<Data> datas = new ArrayList<>();
  private final List<XMLSignature> signatures = new ArrayList<>();
  private final Map properties = new HashMap();

  static final String CHARSET = "UTF-8";

  static final String VERSION = "1.3";
  static final String TAG_SIGNED_DOCUMENT = "SignedDocument";
  static final String TAG_DATA = "Data";
  static final String TAG_CONTENT = "Content";
  static final String TAG_PROPERTIES = "Properties";

  static final String MATRIX_URI = "http://gdmatrix.org/xmldsig";
  static final String MATRIX_NS = "mx";
  static final String TAG_MATRIX_DOCUMENTS = "documents";
  static final String TAG_MATRIX_DOCUMENT = "document";
  static final String TAG_MATRIX_NAME = "name";
  static final String TAG_MATRIX_HASH = "hash";
  static final String TAG_MATRIX_ALGORITHM = "algorithm";

  static final String XMLDSIG_URI = "http://www.w3.org/2000/09/xmldsig#";
  static final String XADES_URI = "http://uri.etsi.org/01903/v1.3.2#";
  static final String XADES122_URI = "http://uri.etsi.org/01903/v1.2.2#";
  static final String XADES141_URI = "http://uri.etsi.org/01903/v1.4.1#";
  static final String DSS_URI = "urn:oasis:names:tc:dss:1.0:core:schema";
  static final String VALID_URI = "http://www.aoc.cat/validador-identitats";
  static final String SIGNED_PROPERTIES_URI = "http://uri.etsi.org/01903#SignedProperties";

  static final String XMLDSIG_NS = "ds";
  static final String XADES_NS = "xades";
  static final String XADES141_NS = "xades141";

  static final String TAG_QUALIFYING_PROPERTIES = "QualifyingProperties";
  static final String TAG_SIGNED_PROPERTIES = "SignedProperties";
  static final String TAG_UNSIGNED_PROPERTIES = "UnsignedProperties";
  static final String TAG_SIGNED_SIGNATURE_PROPERTIES =
    "SignedSignatureProperties";
  static final String TAG_SIGNING_TIME = "SigningTime";
  static final String TAG_SIGNING_CERTIFICATE = "SigningCertificate";
  static final String TAG_CERT = "Cert";
  static final String TAG_CERT_DIGEST = "CertDigest";
  static final String TAG_ISSUER_SERIAL = "IssuerSerial";

  static final String TAG_SIGNATURE_POLICY_IDENTIFIER =
    "SignaturePolicyIdentifier";
  static final String TAG_SIGNATURE_POLICY_IMPLIED = "SignaturePolicyImplied";
  static final String TAG_SIGNATURE_POLICY_ID = "SignaturePolicyId";
  static final String TAG_SIG_POLICY_ID = "SigPolicyId";
  static final String TAG_SIG_POLICY_HASH = "SigPolicyHash";

  static final String TAG_UNSIGNED_SIGNATURE_PROPERTIES =
    "UnsignedSignatureProperties";
  static final String TAG_SIGNATURE_TIMESTAMP = "SignatureTimeStamp";
  static final String TAG_INCLUDE = "Include";
  static final String TAG_XML_TIMESTAMP = "XMLTimeStamp";
  static final String TAG_ENCAPSULATED_TIMESTAMP = "EncapsulatedTimeStamp";
  static final String TAG_COMPLETE_CERT_REFS = "CompleteCertificateRefs";
  static final String TAG_CERT_REFS = "CertRefs";

  static final String TAG_COMPLETE_REV_REFS = "CompleteRevocationRefs";
  static final String TAG_CRL_REFS = "CRLRefs";
  static final String TAG_CRL_REF = "CRLRef";
  static final String TAG_DIGEST_ALG_VALUE = "DigestAlgAndValue";
  static final String TAG_DIGEST_METHOD = "DigestMethod";
  static final String TAG_DIGEST_VALUE = "DigestValue";
  static final String TAG_CRL_IDENTIFIER = "CRLIdentifier";
  static final String TAG_CRL_ISSUER = "Issuer";
  static final String TAG_CRL_ISSUE_TIME = "IssueTime";
  static final String TAG_CRL_NUMBER = "Number";
  static final String TAG_SIG_REFS_TIMESTAMP = "SigAndRefsTimeStamp";
  static final String TAG_ENC_509_CERT = "EncapsulatedX509Certificate";
  static final String TAG_CERT_VALUES = "CertificateValues";
  static final String TAG_REV_VALUES = "RevocationValues";
  static final String TAG_CRL_VALUES = "CRLValues";
  static final String TAG_ENCAP_CRL_VALUE = "EncapsulatedCRLValue";
  static final String TAG_ARCHIVE_TIMESTAMP = "ArchiveTimeStamp";

  static final String ATT_VERSION = "version";

  /* algorithms */
  static final String HASH_ALGO_ID = ALGO_ID_DIGEST_SHA256;
  static final String HASH_ALGO = "SHA-256";

//  static final String HASH_ALGO_ID = ALGO_ID_DIGEST_SHA1;
//  static final String HASH_ALGO = "SHA-1";


  static boolean createTimeStamp = true; // XAdES T
  static String TIMESTAMP_FORMAT = TAG_ENCAPSULATED_TIMESTAMP; // tag name
  static boolean policy = true;
  static boolean policyImplied = true;

  private String version = VERSION;

  public XMLSignedDocument()
  {
  }

  public String getVersion()
  {
    return version;
  }

  @Override
  public void newDocument() throws Exception
  {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();
    doc = db.newDocument();
    root = doc.createElement(TAG_SIGNED_DOCUMENT);
    root.setAttribute(ATT_VERSION, version);
    doc.appendChild(root);
    BaseURI = new File("c:/signature.xml").toURI().toURL().toString();
    datas.clear();
    signatures.clear();
  }

  @Override
  public void parseDocument(InputStream is) throws Exception
  {
    datas.clear();
    signatures.clear();

    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();
    doc = db.parse(is);
    root = (Element)doc.getFirstChild();

    Element sdocNode = findElement(doc.getFirstChild(),
      null, TAG_SIGNED_DOCUMENT);
    Attr versionAttr = (Attr)sdocNode.getAttributes().getNamedItem(ATT_VERSION);
    if (versionAttr != null)
    {
      version = versionAttr.getValue();
    }

    // load Data sections
    Element dataElement = findElement(sdocNode.getFirstChild(), null, TAG_DATA);
    while (dataElement != null)
    {
      Data data = new Data(dataElement, BaseURI);
      datas.add(data);
      dataElement = findElement(dataElement.getNextSibling(), null, TAG_DATA);
    }
    // load Signatures
    Element sigElement = findElement(sdocNode.getFirstChild(),
      XMLDSIG_URI, Constants._TAG_SIGNATURE);
    while (sigElement != null)
    {
      XMLSignature signature = new XMLSignature(sigElement, BaseURI);
      signatures.add(signature);
      sigElement = findElement(sigElement.getNextSibling(),
        XMLDSIG_URI, Constants._TAG_SIGNATURE);
    }

    registerElementIds();

    LOGGER.log(Level.FINE, "Datas: {0}", datas.size());
    LOGGER.log(Level.FINE, "Signatures: {0}", signatures.size());
  }

  @Override
  public String addData(String dataType, byte[] content, Map properties)
    throws Exception
  {
    Data dataSection = new Data(doc, BaseURI);
    String id = getUniqueId();
    dataSection.setId(id);
    dataSection.setType(dataType);
    dataSection.setContent(doc, content);
    dataSection.setProperties(doc, properties);
    root.appendChild(dataSection.getElement());
    datas.add(dataSection);
    dataSection.getElement().setIdAttribute("Id", true);
    return id;
  }

  @Override
  public byte[] addSignature(X509Certificate cert, String signAlgo,
    String policyId, String policyDigest) throws Exception
  {
    String xmlSignAlgo;
    if (SHA1_RSA_ALGO.equals(signAlgo))
    {
      xmlSignAlgo = XMLSignature.ALGO_ID_SIGNATURE_RSA;
    }
    else if (SHA256_RSA_ALGO.equals(signAlgo))
    {
      xmlSignAlgo = XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256;
    }
    else throw new RuntimeException("UNSUPPORTED_SIGNATURE_ALGORITHM");

    // Create signature
    XMLSignature signature = new XMLSignature(doc, BaseURI, xmlSignAlgo);
    root.appendChild(signature.getElement());
    String signatureId = getUniqueId();
    signature.setId(signatureId);
    signature.getElement().setIdAttribute("Id", true);

    // adding keyInfo:X509Data
    X509Data X509Data = new X509Data(doc);
    X509Data.addIssuerSerial(cert.getIssuerDN().getName(),
      cert.getSerialNumber());
    X509Data.addSubjectName(cert);
    X509Data.addCertificate(cert);
    signature.getKeyInfo().add(X509Data);
    signature.getKeyInfo().setId(getUniqueId());

    // adding keyInfo:KeyValue
    signature.addKeyInfo(cert.getPublicKey());

    // add XAdES object
    String signedPropertiesId = getUniqueId();
    ObjectContainer obj = createXAdESObject(cert,
      signatureId, signedPropertiesId, policyId, policyDigest);
    signature.appendObject(obj);
    signature.addDocument("#" + signedPropertiesId,
      null, HASH_ALGO_ID, getUniqueId(), SIGNED_PROPERTIES_URI);

    // add Documents object
    String documentsId = getUniqueId();
    ObjectContainer docCont = createDocumentObject(documentsId);
    signature.appendObject(docCont);
    signature.addDocument("#" + documentsId,
      null, HASH_ALGO_ID, getUniqueId(), null);

    // adding signature to XMLSignedDocument
    signatures.add(signature);

    // calculate digest
    SignedInfo signedInfo = signature.getSignedInfo();
    signedInfo.setId(getUniqueId());
    signedInfo.generateDigestValues();

    // get data to sign
    org.santfeliu.signature.xmldsig.ByteArrayOutputStream bos =
      new org.santfeliu.signature.xmldsig.ByteArrayOutputStream();
    signedInfo.signInOctetStream(bos);
    byte[] dataToSign = bos.toByteArray();

    return dataToSign;
  }

  @Override
  public void setSignatureValue(byte[] signatureData)
    throws Exception
  {
    // get last signature
    XMLSignature signature = signatures.get(signatures.size() - 1);

    // ------------- adding signatureData --------------
    Element signatureValueElem = findElement(
      signature.getElement().getFirstChild(),
      XMLDSIG_URI, Constants._TAG_SIGNATUREVALUE);

    // set signatureValueId
    signatureValueElem.setAttribute("Id", getUniqueId());

    while (signatureValueElem.hasChildNodes())
    {
      signatureValueElem.removeChild(signatureValueElem.getFirstChild());
    }
    String base64codedValue = Base64.getMimeEncoder().
      encodeToString(signatureData);

    if (base64codedValue.length() > 76)
    {
      base64codedValue = "\n" + base64codedValue + "\n";
    }
    signatureValueElem.setTextContent(base64codedValue);

    if (createTimeStamp)
    {
      addTimeStamp(signature, XADES_URI, TAG_SIGNATURE_TIMESTAMP,
        getSignatureTimeStampElements(signature), false);
    }
  }

  @Override
  public void removeSignature() throws Exception
  {
    // remove the last signature
    Node node = doc.getFirstChild().getLastChild();
    if (node.getLocalName().equals(Constants._TAG_SIGNATURE))
    {
      doc.getFirstChild().removeChild(node);
      signatures.remove(signatures.size() - 1);
    }
  }

  @Override
  public List<DataHash> digestData() throws Exception
  {
    ArrayList<DataHash> dataHashList = new ArrayList<>();
    for (int i = 0; i < datas.size(); i++)
    {
      Data data = (Data)datas.get(i);
      DataHash dataHash = new DataHash();
      dataHash.setName(data.getId());
      dataHash.setHash(data.digest(HASH_ALGO_ID));
      dataHash.setAlgorithm(HASH_ALGO);
      dataHashList.add(dataHash);
      if ("url".equals(data.getType()))
      {
        // add additional DataHash for the external content referenced by url
        String url = data.getText();
        URL docUrl = new URL(url);
        MessageDigest messageDigest = MessageDigest.getInstance(HASH_ALGO);
        URLConnection conn = docUrl.openConnection();
        conn.setConnectTimeout(3600000); // 1 hour
        conn.setReadTimeout(3600000); // 1 hour
        try (InputStream is = conn.getInputStream())
        {
          int n = 0;
          byte[] buffer = new byte[8192];
          while (n != -1)
          {
            n = is.read(buffer);
            if (n > 0)
            {
              messageDigest.update(buffer, 0, n);
            }
          }
          byte[] hash = messageDigest.digest();
          dataHash = new DataHash();
          dataHash.setName(url);
          dataHash.setHash(hash);
          dataHash.setAlgorithm(HASH_ALGO);
          dataHashList.add(dataHash);
        }
      }
    }
    return dataHashList;
  }

  @Override
  public void addExternalSignature(byte[] signatureElementData) throws Exception
  {
    ByteArrayInputStream is = new ByteArrayInputStream(signatureElementData);
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    dbf.setNamespaceAware(true);
    javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();
    Document signDoc = db.parse(is);
    Element documentElement = signDoc.getDocumentElement();
    if (!documentElement.getLocalName().equals(Constants._TAG_SIGNATURE))
      throw new Exception("INVALID_SIGNATURE_FORMAT");

    Element signatureElement = (Element)doc.importNode(documentElement, true);
    doc.getDocumentElement().appendChild(signatureElement);

    XMLSignature signature = new XMLSignature(signatureElement, BaseURI);
    signatures.add(signature);

    // replace catcert XMLTimeStamp (xades-1.2.2)
    NodeList nodeList = signatureElement.getElementsByTagNameNS(XADES122_URI,
      TAG_SIGNATURE_TIMESTAMP);
    if (nodeList.getLength() > 0)
    {
      Element oldTimeStampElement = (Element)nodeList.item(0);
      if (oldTimeStampElement.getNextSibling() == null)
      {
        oldTimeStampElement.getParentNode().removeChild(oldTimeStampElement);

        addTimeStamp(signature, XADES122_URI, TAG_SIGNATURE_TIMESTAMP,
          getSignatureTimeStampElements(signature), true);
      }
    }
    registerElementIds();
  }

  @Override
  public DocumentValidation validate(List<String> options) throws Exception
  {
    registerElementIds();

    DocumentValidation documentValidation = new DocumentValidation();

    boolean valid = true;
    for (int i = 0; i < signatures.size(); i++)
    {
      XMLSignature signature = (XMLSignature)signatures.get(i);

      SignatureValidation signatureValidation =
        validateSignature(signature, options);

      LOGGER.log(Level.INFO, "Signature {0} validation: {1}",
        new Object[]{i, signatureValidation.isValid()});

      documentValidation.getSignatureValidation().add(signatureValidation);

      valid = valid && signatureValidation.isValid();
    }
    documentValidation.setValid(valid);

    return documentValidation;
  }

  @Override
  public void writeDocument(OutputStream os)
    throws Exception
  {
    String preambul = "<?xml version=\"1.0\" encoding=\"" + CHARSET + "\"?>";
    os.write(preambul.getBytes());
    XMLUtils.outputDOMc14nWithComments(doc, os);
  }

  public void writeSignature(int index, OutputStream os)
    throws Exception
  {
    XMLSignature signature = signatures.get(index);
    String preambul = "<?xml version=\"1.0\" encoding=\"" + CHARSET + "\"?>";
    os.write(preambul.getBytes());
    XMLUtils.outputDOMc14nWithComments(signature.getElement(), os);
  }

  @Override
  public void setId(String id)
  {
    Element elem = (Element)doc.getFirstChild();
    elem.setAttribute("Id", id);
  }

  @Override
  public String getId()
  {
    Element elem = (Element)doc.getFirstChild();
    return elem.getAttribute("Id");
  }

  @Override
  public String getMimeType()
  {
    return "text/xml";
  }

  @Override
  public Map getProperties()
  {
    return properties;
  }

  public Data getData(int index)
  {
    return datas.get(index);
  }

  public Data getDataById(String id)
  {
    for (Data data : datas)
    {
      if (data.getId().equals(id)) return data;
    }
    return null;
  }

  public XMLSignature getSignature(int index)
  {
    return (XMLSignature)signatures.get(index);
  }

  public SignatureValidation validateSignature(XMLSignature signature,
    List<String> options)
  {
    SignatureValidation signatureValidation = new SignatureValidation();
    signatureValidation.setSignatureId(signature.getId());
    signatureValidation.setFormat("XMLDSIG");
    signatureValidation.setValid(true); // assume signature is valid

    try
    {
      boolean preserve = options.contains(PRESERVE_OPTION);

      if (!validateDataHashes(signature))
      {
        addValidationDetail(signatureValidation,
          DATA_NOT_INTACT_CODE, "Data not intact.");
      }

      SignedInfo signedInfo = signature.getSignedInfo();
      int numRef = signedInfo.getLength();
      for (int i = 0; i < numRef; i++)
      {
        Reference ref = signedInfo.item(i);
        String uri = ref.getURI();
        LOGGER.log(Level.INFO, "Validating reference {0}: {1}",
          new Object[]{uri, ref.verify()});
      }

      KeyInfo keyInfo = signature.getKeyInfo();
      X509Certificate signingCertificate = null;
      if (keyInfo != null)
      {
        signingCertificate = keyInfo.getX509Certificate();
        if (signingCertificate != null)
        {
          String signerDN = signingCertificate.getSubjectDN().getName();
          LOGGER.log(Level.INFO, "Certificate found: {0}", signerDN);
          signatureValidation.setSigner(signerDN);
          if (!signature.checkSignatureValue(signingCertificate))
          {
            addValidationDetail(signatureValidation,
              DATA_NOT_INTACT_CODE, "Signature invalid.");
          }
        }
        else
        {
          PublicKey pk = signature.getKeyInfo().getPublicKey();
          if (pk == null)
          {
            addValidationDetail(signatureValidation,
              INVALID_FORMAT_CODE, "Public key not found.");
          }
          else
          {
            LOGGER.warning("Certificate not found.");
            if (!signature.checkSignatureValue(pk))
            {
              addValidationDetail(signatureValidation,
                DATA_NOT_INTACT_CODE, "Data not intact.");
            }
          }
        }
      }
      else
      {
        addValidationDetail(signatureValidation,
          INVALID_FORMAT_CODE, "KeyInfo not found.");
      }

      // XADES-B -------------------------------------------------------------

      boolean isXades122 = signature.getElement()
        .getElementsByTagNameNS(XADES122_URI,
          XMLSignedDocument.TAG_QUALIFYING_PROPERTIES).getLength() > 0;

      String xadesUri = isXades122 ? XADES122_URI : XADES_URI;

      List<Date> signingDates = new ArrayList<>(); // sign. dates of sig & TS
      List<Date> expirationDates = new ArrayList<>(); // exp. dates of sig & TS
      int archiveTSCount = 0;

      // look for signingTime
      NodeList nodeList = signature.getElement()
        .getElementsByTagNameNS(xadesUri, TAG_SIGNED_SIGNATURE_PROPERTIES);
      if (nodeList.getLength() > 0)
      {
        signatureValidation.setFormat("XADES-B");

        Element signedPropsElement = (Element)nodeList.item(0);
        nodeList = signedPropsElement
          .getElementsByTagNameNS(xadesUri, TAG_SIGNING_TIME);
        if (nodeList.getLength() > 0)
        {
          String timeValue = ((Element)nodeList.item(0)).getTextContent();
          Date signingDate = parseISODate(timeValue);
          signingDates.add(signingDate);
          signatureValidation.setSigningDateTime(formatInternalDate(signingDate));
        }
        else
        {
          addValidationDetail(signatureValidation,
            INVALID_FORMAT_CODE, "Signing time is not present.");
        }
      }

      if (signingCertificate != null)
      {
        Date expirationDate = signingCertificate.getNotAfter();
        expirationDates.add(expirationDate);
      }

      nodeList = signature.getElement()
        .getElementsByTagNameNS(xadesUri, TAG_UNSIGNED_SIGNATURE_PROPERTIES);
      Element unsignedPropsElement = nodeList.getLength() == 0 ? null :
        (Element)nodeList.item(0);

      if (unsignedPropsElement == null || signingCertificate == null)
      {
        if (preserve)
        {
          addValidationDetail(signatureValidation,
            INVALID_FORMAT_CODE,
            "Can not preserve the signature.");
        }
      }
      else
      {
        List<X509Certificate> certList = new ArrayList<>();
        Map<String, X509CRL> crlMap = new HashMap<>();

        CACertificateStore caStore = CACertificateStore.getInstance();

        caStore.addCertificateChainAndCRLs(signingCertificate, certList, crlMap);

        // XADES-T -----------------------------------------------------------

        nodeList = unsignedPropsElement.getElementsByTagNameNS(xadesUri,
          TAG_SIGNATURE_TIMESTAMP);

        boolean addSignatureTimeStamp = false;
        Element oldTimeStampElement = null;

        if (nodeList.getLength() == 0)
        {
          // timestamp not present
          if (preserve)
          {
            // add timestamp to preserve signature
            addSignatureTimeStamp = true;
          }
        }
        else
        {
          // try to replace XMLTimeStamp by EncapsulatedTimeStamp (CMS).
          // XMLTimeStamp are not recognized by the EU validation tool.
          Element timeStampElement = (Element)nodeList.item(0);
          if (preserve && timeStampElement.getNextSibling() == null &&
              TIMESTAMP_FORMAT.equals(TAG_ENCAPSULATED_TIMESTAMP) &&
              timeStampElement.getElementsByTagNameNS(xadesUri,
              TAG_XML_TIMESTAMP).getLength() > 0)
          {
            oldTimeStampElement = timeStampElement;
            addSignatureTimeStamp = true;
          }
        }

        if (addSignatureTimeStamp)
        {
          if (isValidCertificate(signingCertificate))
          {
            // signing certificate is still valid today
            if (oldTimeStampElement != null)
            {
              // previous XMLTimeStamp exists, replace by EncapsultatedTimeStamp.
              oldTimeStampElement.getParentNode().removeChild(oldTimeStampElement);
              LOGGER.log(Level.INFO,
                "SignatureTimeStamp of type XMLTimeStamp was removed.");
            }
            addTimeStamp(signature, xadesUri, TAG_SIGNATURE_TIMESTAMP,
              getSignatureTimeStampElements(signature), isXades122);
            LOGGER.log(Level.INFO,
              "Added a SignatureTimeStamp of type {0}", TIMESTAMP_FORMAT);
          }
          else if (oldTimeStampElement == null)
          {
            addValidationDetail(signatureValidation,
              UNTRUSTED_SIGNATURE_CODE,
              "Can not add a timestamp because signing certificate is not valid.");
          }
        }

        nodeList = unsignedPropsElement
          .getElementsByTagNameNS(xadesUri, TAG_SIGNATURE_TIMESTAMP);
        if (nodeList.getLength() > 0)
        {
          Element timeStampElement = (Element)nodeList.item(0);
          loadTimeStampInfo(xadesUri, timeStampElement,
            signingDates, expirationDates, certList, crlMap);

          signatureValidation.setFormat("XADES-T");
        }

        // XADES-C -----------------------------------------------------------

        if (unsignedPropsElement.getElementsByTagNameNS(
            xadesUri, TAG_COMPLETE_CERT_REFS).getLength() > 0)
        {
          signatureValidation.setFormat("XADES-C");
        }
        else if (preserve)
        {
          Element compCertRefsElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_COMPLETE_CERT_REFS);
          compCertRefsElement.setAttribute("Id", getUniqueId());
          compCertRefsElement.setIdAttribute("Id", true);

          unsignedPropsElement.appendChild(compCertRefsElement);

          Element certRefsElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_CERT_REFS);
          compCertRefsElement.appendChild(certRefsElement);

          for (int i = 1; i < certList.size(); i++)
          {
            X509Certificate cert = certList.get(i);
            Element certElement = createCertDigest(xadesUri, cert);
            certRefsElement.appendChild(certElement);
          }
          signatureValidation.setFormat("XADES-C");
        }

        if (unsignedPropsElement.getElementsByTagNameNS(
            xadesUri, TAG_COMPLETE_REV_REFS).getLength() > 0)
        {
          signatureValidation.setFormat("XADES-C");
        }
        else if (preserve)
        {
          Element compRevRefsElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_COMPLETE_REV_REFS);
          compRevRefsElement.setAttribute("Id", getUniqueId());
          compRevRefsElement.setIdAttribute("Id", true);
          unsignedPropsElement.appendChild(compRevRefsElement);

          Element crlRefsElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_CRL_REFS);
          compRevRefsElement.appendChild(crlRefsElement);

          for (X509CRL crl : crlMap.values())
          {
            Element crlRefElement = this.createCRLDigest(xadesUri, crl);
            crlRefsElement.appendChild(crlRefElement);
          }
          signatureValidation.setFormat("XADES-C");
        }

        // XADES-X -----------------------------------------------------------

        if (unsignedPropsElement.getElementsByTagNameNS(
            xadesUri, TAG_SIG_REFS_TIMESTAMP).getLength() > 0)
        {
          signatureValidation.setFormat("XADES-X");
        }
        else if (preserve)
        {
          addTimeStamp(signature, xadesUri, TAG_SIG_REFS_TIMESTAMP,
            getSigAndRefsTimeStampElements(signature), isXades122);
          signatureValidation.setFormat("XADES-X");
        }

        nodeList = unsignedPropsElement
          .getElementsByTagNameNS(xadesUri, TAG_SIG_REFS_TIMESTAMP);
        if (nodeList.getLength() > 0)
        {
          Element timeStampElement = (Element)nodeList.item(0);
          loadTimeStampInfo(xadesUri, timeStampElement,
            signingDates, expirationDates, certList, crlMap);
        }

        // XADES-XL -------------------------------------------------------------

        if (unsignedPropsElement.getElementsByTagNameNS(
            xadesUri, TAG_CERT_VALUES).getLength() > 0)
        {
          signatureValidation.setFormat("XADES-XL");
        }
        else if (preserve)
        {
          Element certValuesElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_CERT_VALUES);
          certValuesElement.setAttribute("Id", getUniqueId());
          certValuesElement.setIdAttribute("Id", true);
          unsignedPropsElement.appendChild(certValuesElement);

          for (X509Certificate certValue : certList)
          {
            Element encapCertElement = doc.createElementNS(xadesUri,
              XADES_NS + ":" + TAG_ENC_509_CERT);
            certValuesElement.appendChild(encapCertElement);
            byte[] certEncoded = certValue.getEncoded();
            encapCertElement.setTextContent(
              Base64.getEncoder().encodeToString(certEncoded));
          }
          signatureValidation.setFormat("XADES-XL");
        }

        if (unsignedPropsElement.getElementsByTagNameNS(
            xadesUri, TAG_REV_VALUES).getLength() > 0)
        {
          signatureValidation.setFormat("XADES-XL");
        }
        else if (preserve)
        {
          Element revValuesElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_REV_VALUES);
          revValuesElement.setAttribute("Id", getUniqueId());
          revValuesElement.setIdAttribute("Id", true);
          unsignedPropsElement.appendChild(revValuesElement);

          Element crlValuesElement = doc.createElementNS(xadesUri,
            XADES_NS + ":" + TAG_CRL_VALUES);
          revValuesElement.appendChild(crlValuesElement);

          for (X509CRL crl : crlMap.values())
          {
            Element crlValueElement = doc.createElementNS(xadesUri,
              XADES_NS + ":" + XMLSignedDocument.TAG_ENCAP_CRL_VALUE);
            crlValuesElement.appendChild(crlValueElement);
            byte[] crlEncoded = crl.getEncoded();
            crlValueElement.setTextContent(
              Base64.getEncoder().encodeToString(crlEncoded));
          }
          signatureValidation.setFormat("XADES-XL");
        }

        // XADES-A -----------------------------------------------------------

        if (preserve)
        {
          // Add ArchiveTimeStamp xades#1.4.1 despite it is not supported in
          // xades#1.2.2
          // EU validation tool is able to validate these signatures.

          addTimeStamp(signature, XADES141_URI, TAG_ARCHIVE_TIMESTAMP,
            getArchiveTimeStampElements(signature), false);
        }

        nodeList = unsignedPropsElement
          .getElementsByTagNameNS(XADES141_URI, TAG_ARCHIVE_TIMESTAMP);

        archiveTSCount = nodeList.getLength();

        for (int i = 0; i < archiveTSCount; i++)
        {
          Element timeStampElement = (Element)nodeList.item(i);
          loadTimeStampInfo(xadesUri, timeStampElement,
            signingDates, expirationDates, certList, crlMap);
        }

        if (archiveTSCount > 0)
        {
          signatureValidation.setFormat("XADES-A");
        }
      }

      Date expirationDate = getExpirationDate(signingDates, expirationDates);
      signatureValidation.setExpirationDateTime(formatInternalDate(expirationDate));
      if (expirationDate.before(new Date()))
      {
        // signature is untrusted
        addValidationDetail(signatureValidation,
          UNTRUSTED_SIGNATURE_CODE,
          "Signature is not trusted.");
      }
      else if (signatureValidation.isValid())
      {
        // signature is valid
        if (preserve)
        {
          addValidationDetail(signatureValidation,
            SIGNATURE_PRESERVED_CODE,
            "Signature preserved. ArchiveTimeStamps: {0} ", archiveTSCount);
        }
      }
    }
    catch (Exception ex)
    {
      ex.printStackTrace();
      addValidationDetail(signatureValidation,
        UNEXPECTED_EXCEPTION_CODE,
        "Error validating signature: {0}", ex.toString());
    }
    return signatureValidation;
  }

  public int getDataCount()
  {
    return datas.size();
  }

  public int getSignaturesCount()
  {
    return signatures.size();
  }

  public byte[] toByteArray() throws Exception
  {
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    writeDocument(os);
    return os.toByteArray();
  }

  public Document getDOM()
  {
    return doc;
  }

  //*****************************************************************

  private ObjectContainer createXAdESObject(X509Certificate cert,
    String signatureId, String signedPropertiesId,
    String policyId, String policyDigest) throws Exception
  {
    ObjectContainer obj = new ObjectContainer(doc);
    obj.setId(getUniqueId());

    Element qualPropElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_QUALIFYING_PROPERTIES);
    obj.appendChild(qualPropElement);
    qualPropElement.setAttributeNS(Constants.NamespaceSpecNS,
      "xmlns:" + XADES_NS, XADES_URI);
    qualPropElement.setAttribute("Target", "#" + signatureId);

    Element sigPropElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_SIGNED_PROPERTIES);
    qualPropElement.appendChild(sigPropElement);
    sigPropElement.setAttribute("Id", signedPropertiesId);
    sigPropElement.setIdAttribute("Id", true);

    Element signaturePropElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_SIGNED_SIGNATURE_PROPERTIES);
    sigPropElement.appendChild(signaturePropElement);

    Element sigTimeElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_SIGNING_TIME);
    signaturePropElement.appendChild(sigTimeElement);

    sigTimeElement.setTextContent(formatISODate(new Date()));

    Element sigCertElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_SIGNING_CERTIFICATE);
    signaturePropElement.appendChild(sigCertElement);

    Element certElement = createCertDigest(XADES_URI, cert);
    sigCertElement.appendChild(certElement);

    if (policy)
    {
      Element sigPolElement = doc.createElementNS(XADES_URI,
        XADES_NS + ":" + TAG_SIGNATURE_POLICY_IDENTIFIER);
      signaturePropElement.appendChild(sigPolElement);

      if (policyImplied)
      {
        Element polElement = doc.createElementNS(XADES_URI,
          XADES_NS + ":" + TAG_SIGNATURE_POLICY_IMPLIED);
        sigPolElement.appendChild(polElement);
      }
      else
      {
        Element sigPolIdElement = doc.createElementNS(XADES_URI,
          XADES_NS + ":" + TAG_SIGNATURE_POLICY_ID);
        sigPolElement.appendChild(sigPolIdElement);

        Element sigIdElement = doc.createElementNS(XADES_URI,
          XADES_NS + ":" + TAG_SIG_POLICY_ID);
        sigPolIdElement.appendChild(sigIdElement);
        sigIdElement.appendChild(doc.createTextNode(policyId));

        Element sigHashElement = doc.createElementNS(XADES_URI,
          XADES_NS + ":" + TAG_SIG_POLICY_HASH);
        sigPolIdElement.appendChild(sigHashElement);

        Element policyDigestMethodElement =
          doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_DIGESTMETHOD);
        sigHashElement.appendChild(policyDigestMethodElement);
        policyDigestMethodElement.setAttribute("Algorithm", HASH_ALGO_ID);

        Element policyDigestValueElement =
          doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_DIGESTVALUE);
        sigHashElement.appendChild(policyDigestValueElement);
        policyDigestValueElement.appendChild(doc.createTextNode(policyDigest));
      }
    }

    Element unsigPropElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_UNSIGNED_PROPERTIES);
    qualPropElement.appendChild(unsigPropElement);

    Element unsigSignaturePropElement = doc.createElementNS(XADES_URI,
      XADES_NS + ":" + TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    unsigPropElement.appendChild(unsigSignaturePropElement);

    return obj;
  }

  private ObjectContainer createDocumentObject(String documentsId)
    throws Exception
  {
    ObjectContainer obj = new ObjectContainer(doc);

    Element element = obj.getElement();
    element.setAttribute("Id", documentsId);
    element.setIdAttribute("Id", true);

    Element documentsElement =
      doc.createElementNS(MATRIX_URI, MATRIX_NS + ":" + TAG_MATRIX_DOCUMENTS);
    documentsElement.setAttribute("xmlns:" + MATRIX_NS, MATRIX_URI);
    element.appendChild(documentsElement);

    List<DataHash> dataHashes = digestData();
    for (DataHash dataHash : dataHashes)
    {
      Element documentElement = doc.createElementNS(MATRIX_URI,
        MATRIX_NS + ":" + TAG_MATRIX_DOCUMENT);
      documentsElement.appendChild(documentElement);

      Element nameElement = doc.createElementNS(MATRIX_URI,
        MATRIX_NS + ":" + TAG_MATRIX_NAME);
      nameElement.setTextContent(dataHash.getName());
      documentElement.appendChild(nameElement);

      Element hashElement = doc.createElementNS(MATRIX_URI,
        MATRIX_NS + ":" + TAG_MATRIX_HASH);
      hashElement.setTextContent(
        Base64.getMimeEncoder().encodeToString(dataHash.getHash()));
      documentElement.appendChild(hashElement);

      Element algorithmElement = doc.createElementNS(MATRIX_URI,
        MATRIX_NS + ":" + TAG_MATRIX_ALGORITHM);
      algorithmElement.setTextContent(dataHash.getAlgorithm());
      documentElement.appendChild(algorithmElement);
    }
    return obj;
  }

  private Element createCertDigest(String xadesUri, X509Certificate cert)
    throws Exception
  {
    Element certElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CERT);

    Element certDigestElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CERT_DIGEST);
    certElement.appendChild(certDigestElement);

    Element digestMethodElement =
      doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_DIGESTMETHOD);
    certDigestElement.appendChild(digestMethodElement);
    digestMethodElement.setAttribute("Algorithm", HASH_ALGO_ID);

    MessageDigest messageDigest = MessageDigest.getInstance(HASH_ALGO);
    byte[] digest = messageDigest.digest(cert.getEncoded());

    Element digestValueElement =
      doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_DIGESTVALUE);
    certDigestElement.appendChild(digestValueElement);
    digestValueElement.appendChild(doc.createTextNode(
      Base64.getMimeEncoder().encodeToString(digest)));

    Element issuerSerialElement =
      doc.createElementNS(xadesUri, XADES_NS + ":" + TAG_ISSUER_SERIAL);
    certElement.appendChild(issuerSerialElement);

    Element issuerNameElement =
      doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_X509ISSUERNAME);
    issuerSerialElement.appendChild(issuerNameElement);
    issuerNameElement.appendChild(
      doc.createTextNode(cert.getIssuerDN().getName()));

    Element issuerSNElement =
      doc.createElement(XMLDSIG_NS + ":" + Constants._TAG_X509SERIALNUMBER);
    issuerSerialElement.appendChild(issuerSNElement);
    issuerSNElement.appendChild(
      doc.createTextNode(cert.getSerialNumber().toString()));

    return certElement;
  }

  private Element createCRLDigest(String xadesUri, X509CRL crl)
    throws Exception
  {
    Element crlRefElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CRL_REF);

    Element digAlgValueElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_DIGEST_ALG_VALUE);
    crlRefElement.appendChild(digAlgValueElement);

    Element digMethodElement = doc.createElementNS(xadesUri,
      XMLDSIG_NS + ":" + TAG_DIGEST_METHOD);

    MessageDigest md = MessageDigest.getInstance(HASH_ALGO);
    md.reset();
    md.update(crl.getEncoded());
    byte[] digest = md.digest();

    digMethodElement.setAttribute("Algorithm", HASH_ALGO_ID);
    digAlgValueElement.appendChild(digMethodElement);

    Element digValueElement = doc.createElementNS(xadesUri,
      XMLDSIG_NS + ":" + TAG_DIGEST_VALUE);
    digValueElement.setTextContent(
      Base64.getEncoder().encodeToString(digest));
    digAlgValueElement.appendChild(digValueElement);

    Element crlIdElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CRL_IDENTIFIER);
    crlRefElement.appendChild(crlIdElement);

    Element crlIssuerElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CRL_ISSUER);
    crlIssuerElement.setTextContent(crl.getIssuerX500Principal().getName());
    crlIdElement.appendChild(crlIssuerElement);

    Element crlIssueTimeElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CRL_ISSUE_TIME);
    crlIssueTimeElement.setTextContent(formatISODate(crl.getThisUpdate()));
    crlIdElement.appendChild(crlIssueTimeElement);

    Element crlNumberElement = doc.createElementNS(xadesUri,
      XADES_NS + ":" + TAG_CRL_NUMBER);
    byte[] value = crl.getExtensionValue("2.5.29.20");

    ASN1OctetString octetString = ASN1OctetString.getInstance(value);
    CRLNumber crlNumber = CRLNumber.getInstance(octetString.getOctets());
    BigInteger number = crlNumber.getCRLNumber();

    crlNumberElement.setTextContent(number.toString());
    crlIdElement.appendChild(crlNumberElement);

    return crlRefElement;
  }

  private void addTimeStamp(XMLSignature signature, String tsUri, String tsName,
    List<Element> signedElements, boolean addIncludes) throws Exception
  {
    boolean isXades122 = signature.getElement()
      .getElementsByTagNameNS(XADES122_URI,
        XMLSignedDocument.TAG_QUALIFYING_PROPERTIES).getLength() > 0;

    String xadesUri = isXades122 ? XADES122_URI : XADES_URI;

    String tsNs = tsUri.equals(XADES141_URI) ? XADES141_NS : XADES_NS;

    Element signatureElement = signature.getElement();

    NodeList nodeList =
      signatureElement.getElementsByTagNameNS(xadesUri,
        TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    Element unsigSignaturePropElement = (Element)nodeList.item(0);

    Element timeStampElement = doc.createElementNS(tsUri, tsNs + ":" + tsName);
    timeStampElement.setAttribute("Id", getUniqueId());
    timeStampElement.setIdAttribute("Id", true);
    if (tsNs.equals(XADES141_NS))
    {
      timeStampElement.setAttribute("xmlns:" + XADES141_NS, XADES141_URI);
    }

    unsigSignaturePropElement.appendChild(timeStampElement);

    for (int i = 0; i < signedElements.size(); i++)
    {
      Element signedElement = signedElements.get(i);
      String id = signedElement.getAttribute("Id");

      boolean refData = signedElement.getLocalName().equals("Reference");
      if (refData)
      {
        String URI = signedElement.getAttribute("URI");
        if (URI.startsWith("#"))
        {
          String referenceDataId = URI.substring(1);
          // replace by data to sign
          signedElement = (Element)doc.getElementById(referenceDataId);
          signedElements.set(i, signedElement);
        }
        else throw new Exception("Unsupported external reference");
      }

      if (addIncludes)
      {
        // add Include (explict)
        Element include = doc.createElementNS(xadesUri,
          XADES_NS + ":" + TAG_INCLUDE);

        include.setAttribute("referencedData", String.valueOf(refData));
        include.setAttribute("URI", "#" + id);
        timeStampElement.appendChild(include);
      }
    }

    // CanonicalizationMethod
    Element canonicalizationMethod = doc.createElementNS(
      Constants.SignatureSpecNS,
      XMLDSIG_NS + ":" + Constants._TAG_CANONICALIZATIONMETHOD);
    canonicalizationMethod.setAttribute("Algorithm",
      "http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
    timeStampElement.appendChild(canonicalizationMethod);

    byte[] digestTst = calculateElementsDigest(signedElements);

    if (TAG_XML_TIMESTAMP.equals(TIMESTAMP_FORMAT))
    {
      // XMLTimeStamp
      Element XMLTimeStamp = doc.createElementNS(xadesUri,
        XADES_NS + ":" + TAG_XML_TIMESTAMP);
      XMLTimeStamp.setAttribute("xmlns:dss",
        "urn:oasis:names:tc:dss:1.0:core:schema");
      timeStampElement.appendChild(XMLTimeStamp);

      SecurityProvider provider = SecurityUtils.getSecurityProvider();

      Element sigTimeStamp =
        provider.createXMLTimeStamp(digestTst, HASH_ALGO_ID, null);
      XMLTimeStamp.appendChild(XMLTimeStamp.getOwnerDocument().importNode(
        sigTimeStamp, true));
    }
    else
    {
      // CMSTimeStamp
      Element CMSTimeStamp = doc.createElementNS(xadesUri,
        XADES_NS + ":" + TAG_ENCAPSULATED_TIMESTAMP);

      timeStampElement.appendChild(CMSTimeStamp);

      byte[] cms;
      TimeStampService timeStampService = SecurityUtils.getTimeStampService();
      if (timeStampService != null && SecurityUtils.isTimeStampServicePreferred())
      {
        cms = timeStampService.timestamp(digestTst, HASH_ALGO).getEncoded();
      }
      else
      {
        SecurityProvider provider = SecurityUtils.getSecurityProvider();
        cms = provider.createCMSTimeStamp(digestTst, HASH_ALGO_ID, null);
      }
      CMSTimeStamp.setTextContent(Base64.getEncoder().encodeToString(cms));
    }
  }

  private String getMimeType(String contentType)
  {
    int index = contentType.indexOf(";");
    return (index == -1) ? contentType : contentType.substring(0, index);
  }

  private void registerElementIds()
  {
    // set Id attributes
    NodeList nodes = doc.getElementsByTagName("*");
    for (int index = 0; index < nodes.getLength(); index++)
    {
      Node node = nodes.item(index);
      if (node instanceof Element)
      {
        Element element = (Element)node;
        if (element.hasAttribute("Id"))
        {
          element.setIdAttribute("Id", true);
        }
      }
    }
  }

  private byte[] calculateElementsDigest(List<Element> signedElements)
    throws Exception
  {
    MessageDigestAlgorithm mda = MessageDigestAlgorithm.getInstance(
      doc, HASH_ALGO_ID);

    mda.reset();
    DigesterOutputStream diOs = new DigesterOutputStream(mda);
    OutputStream os = new UnsyncBufferedOutputStream(diOs);

    for (Element signedElement : signedElements)
    {
      XMLSignatureInput input = new XMLSignatureInput(signedElement);
      input.updateOutputStream(os);
    }
    os.flush();
    return diOs.getDigestValue();
  }

  private List<Element> getSignatureTimeStampElements(XMLSignature signature)
  {
    List<Element> elements = new ArrayList<>();

    Element signatureValue = findElement(
      signature.getElement().getFirstChild(),
      XMLDSIG_URI, Constants._TAG_SIGNATUREVALUE);

    elements.add(signatureValue);

    return elements;
  }

  private List<Element> getSigAndRefsTimeStampElements(XMLSignature signature)
  {
    List<Element> elements = new ArrayList<>();

    // SignatureValue
    Element signatureValue = findElement(
      signature.getElement().getFirstChild(),
      XMLDSIG_URI, Constants._TAG_SIGNATUREVALUE);
    elements.add(signatureValue);

    // UnsignedSignatureProperties in order of appearance
    NodeList nodeList =
      signature.getElement().getElementsByTagNameNS(XADES_URI,
        TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    if (nodeList.getLength() == 0)
    {
      nodeList = signature.getElement().getElementsByTagNameNS(XADES122_URI,
        TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    }
    Element unsigSignaturePropElement = (Element)nodeList.item(0);

    Element element = (Element)unsigSignaturePropElement.getFirstChild();
    while (element != null)
    {
      elements.add(element);
      element = (Element)element.getNextSibling();
    }
    return elements;
  }

  private List<Element> getArchiveTimeStampElements(XMLSignature signature)
  {
    List<Element> elements = new ArrayList<>();

    // References
    NodeList nodeList = signature.getSignedInfo().getElement()
      .getElementsByTagNameNS(XMLDSIG_URI, "Reference");
    for (int i = 0; i < nodeList.getLength(); i++)
    {
      elements.add((Element)nodeList.item(i));
    }

    // SignedInfo
    Element signedInfoElement = signature.getSignedInfo().getElement();
    elements.add(signedInfoElement);

    // SignatureValue
    Element signatureValue = findElement(
      signature.getElement().getFirstChild(),
      XMLDSIG_URI, Constants._TAG_SIGNATUREVALUE);
    elements.add(signatureValue);

    // KeyInfo
    Element keyInfoElement = signature.getKeyInfo().getElement();
    elements.add(keyInfoElement);

    // UnsignedSigntureProperties in order of appearance
    nodeList = signature.getElement().getElementsByTagNameNS(XADES_URI,
      TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    if (nodeList.getLength() == 0)
    {
      nodeList = signature.getElement().getElementsByTagNameNS(XADES122_URI,
        TAG_UNSIGNED_SIGNATURE_PROPERTIES);
    }

    Element unsigSignaturePropElement = (Element)nodeList.item(0);

    Element child = (Element)unsigSignaturePropElement.getFirstChild();
    while (child != null)
    {
      elements.add(child);
      child = (Element)child.getNextSibling();
    }

    // Add all Objects but that containing QualifyingProperties
    for (int i = 0; i < signature.getObjectLength(); i++)
    {
      ObjectContainer objectItem = signature.getObjectItem(i);
      String localName = objectItem.getElement().getFirstChild().getLocalName();
      if (!localName.equals(TAG_QUALIFYING_PROPERTIES))
      {
        elements.add(objectItem.getElement());
      }
    }

    return elements;
  }

  private String getUniqueId()
  {
    return "id-" + UUID.randomUUID().toString();
  }

  private boolean isValidCertificate(X509Certificate cert)
  {
    try
    {
      // TODO: call SecurityProvider.validateCertificate(cert);
      cert.checkValidity();
      return true;
    }
    catch (CertificateExpiredException | CertificateNotYetValidException ex)
    {
      return false;
    }
  }

  private boolean validateDataHashes(XMLSignature signature)
    throws Exception
  {
    Element signatureElement = signature.getElement();

    NodeList nodeList;

    nodeList = signatureElement.getElementsByTagNameNS(MATRIX_URI, "document");

    boolean valid = true;

    // MATRIX signatures
    for (int i = 0; i < nodeList.getLength() && valid; i++)
    {
      Node node = nodeList.item(i).getFirstChild();
      String name = findElement(node,
        MATRIX_URI, TAG_MATRIX_NAME).getTextContent();
      String hash = findElement(node,
        MATRIX_URI, TAG_MATRIX_HASH).getTextContent();
      String algorithm = findElement(node,
        MATRIX_URI, TAG_MATRIX_ALGORITHM).getTextContent();

      // TODO: validate external references
      if (name.startsWith("http")) continue;

      Data data = getDataById(name);
      if (data == null)
        throw new Exception("Invalid data reference: " + name);

      String hashAlgorithmURN;
      if ("SHA-1".equals(algorithm))
      {
        hashAlgorithmURN = ALGO_ID_DIGEST_SHA1;
      }
      else if ("SHA-256".equals(algorithm))
      {
        hashAlgorithmURN = ALGO_ID_DIGEST_SHA256;
      }
      else throw new Exception("Unsupported hash algorithm " + algorithm);

      byte[] digest = data.digest(hashAlgorithmURN);
      String digestBase64 = Base64.getEncoder().encodeToString(digest);

      valid = digestBase64.equals(hash);
    }

    // VALID signatures
    nodeList = signatureElement.getElementsByTagNameNS(VALID_URI,
      "evidenciaSignaturaOrdinaria");
    if (nodeList.getLength() > 0)
    {
      Node node = nodeList.item(0).getFirstChild();
      node = findElement(node, VALID_URI, "document");

      while (node != null && valid)
      {
        Node child = node.getFirstChild();
        node = findElement(node.getNextSibling(), VALID_URI, "document");

        String name = findElement(child,
          VALID_URI, "nom").getTextContent();
        String hash = findElement(child,
          VALID_URI, "resum").getTextContent();
        String algorithm = findElement(child,
          VALID_URI, "algorisme").getTextContent();

        // TODO: validate external references
        if (name.startsWith("http")) continue;

        Data data = getDataById(name);
        if (data == null)
          throw new Exception("Invalid data reference: " + name);

        String hashAlgorithmURN;
        if ("SHA-1".equals(algorithm))
        {
          hashAlgorithmURN = ALGO_ID_DIGEST_SHA1;
        }
        else if ("SHA-256".equals(algorithm))
        {
          hashAlgorithmURN = ALGO_ID_DIGEST_SHA256;
        }
        else throw new Exception("Unsupported hash algorithm " + algorithm);

        byte[] digest = data.digest(hashAlgorithmURN);
        String digestBase64 = Base64.getEncoder().encodeToString(digest);

        valid = digestBase64.equals(hash);
      }
    }

    return valid;
  }

  private void loadTimeStampInfo(String xadesUri, Element timeStampElement,
    List<Date> signingDates, List<Date> expirationDates,
    List<X509Certificate> certList, Map<String, X509CRL> crlMap)
    throws Exception
  {
    byte[] certEncoded;

    NodeList nodeList = timeStampElement
      .getElementsByTagNameNS(DSS_URI, "CreationTime");
    if (nodeList.getLength() > 0)
    {
      // XMLTimeStamp
      Element creationTimeElement = (Element)nodeList.item(0);
      String creationTime = creationTimeElement.getTextContent();
      signingDates.add(parseISODate(creationTime));

      nodeList = timeStampElement.getElementsByTagNameNS(XMLDSIG_URI,
        "X509Certificate");
      if (nodeList.getLength() == 0)
        throw new Exception("The certificate of the timestamp is not present.");

      String certBase64 = ((Element)nodeList.item(0)).getTextContent();
      certEncoded = Base64.getDecoder().decode(certBase64);
    }
    else
    {
      // EncapsulatedTimeStamp
      nodeList = timeStampElement
        .getElementsByTagNameNS(xadesUri, TAG_ENCAPSULATED_TIMESTAMP);
      if (nodeList.getLength() > 0)
      {
        String tsBase64 = nodeList.item(0).getTextContent();
        byte[] tsEncoded = Base64.getDecoder().decode(tsBase64);
        TimeStampToken tsToken = new TimeStampToken(new CMSSignedData(tsEncoded));
        Date creationDate = tsToken.getTimeStampInfo().getGenTime();
        signingDates.add(creationDate);

        Store<X509CertificateHolder> certificates = tsToken.getCertificates();
        Collection<X509CertificateHolder> matches = certificates.getMatches(null);
        certEncoded = matches.iterator().next().getEncoded();
      }
      else throw new Exception("Invalid timestamp");
    }

    CertificateFactory cf = CertificateFactory.getInstance("X509");
    X509Certificate tsCert = (X509Certificate)cf.generateCertificate(
      new ByteArrayInputStream(certEncoded));
    expirationDates.add(tsCert.getNotAfter());

    CACertificateStore caStore = CACertificateStore.getInstance();
    caStore.addCertificateChainAndCRLs(tsCert, certList, crlMap);
  }

  private void addValidationDetail(SignatureValidation signatureValidation,
    String code, String message, Object ...args)
  {
    if (code.startsWith("error:"))
    {
      signatureValidation.setValid(false);
    }

    ValidationDetail detail = new ValidationDetail();
    signatureValidation.getValidationDetail().add(detail);

    detail.setCode(code);

    if (message != null)
    {
      if (args == null)
      {
        detail.setMessage(message);
      }
      else
      {
        MessageFormat mf = new MessageFormat(message);
        detail.setMessage(mf.format(args));
      }
      LOGGER.log(Level.FINE, message, args);
    }
  }

  private Element findElement(Node node, String uri, String localName)
  {
    while (node != null)
    {
      if (node instanceof Element)
      {
        Element child = (Element)node;

        if ((uri == null || uri.equals(child.getNamespaceURI())) &&
          child.getLocalName().equals(localName))
        {
          return child;
        }
      }
      node = node.getNextSibling();
    }
    return null;
  }

  private Date getExpirationDate(
    List<Date> signingDates, List<Date>expirationDates)
  {
    Date expirationDate;

    LOGGER.log(Level.INFO, "signingDates: {0}", signingDates);
    LOGGER.log(Level.INFO, "expirationDates: {0}", expirationDates);

    if (signingDates.isEmpty() || expirationDates.isEmpty())
    {
      expirationDate = new Date(0);
    }
    else
    {
      expirationDate = expirationDates.get(0);
      int i = 1;
      while (i < signingDates.size() && i < expirationDates.size())
      {
        if (signingDates.get(i).after(expirationDates.get(i - 1)))
          break; // trust chain is broken

        expirationDate = expirationDates.get(i);
        i++;
      }
    }
    return expirationDate;
  }

  private Date parseISODate(String dateTime) throws ParseException
  {
    return new Date(OffsetDateTime.parse(dateTime).toInstant().toEpochMilli());
  }

  private String formatISODate(Date date)
  {
    SimpleDateFormat dateFormat =
      new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
    return dateFormat.format(date);
  }

  private String formatInternalDate(Date date)
  {
    return TextUtils.formatDate(date, "yyyyMMddHHmmss");
  }

  static
  {
    // init apache lib
    try
    {
      org.apache.xml.security.Init.init();
      ResourceResolver.registerAtStart(
        "org.santfeliu.signature.xmldsig.HTTPResolver");
      ResourceResolver.registerAtStart(
        "org.santfeliu.signature.xmldsig.DetachedResolver");
    }
    catch (Exception ex)
    {
      LOGGER.warning(ex.toString());
    }
  }

  public static void main(String[] args)
  {
    try
    {
      MatrixConfig.setProperty("org.santfeliu.security.urlCredentialsCipher.secret",
        "A2b25T939");

      MatrixConfig.setProperty("org.santfeliu.security.tspURL",
        "http://timestamp.sectigo.com/qualified");

      XMLSignedDocument doc = new XMLSignedDocument();
      doc.parseDocument(new FileInputStream("c:/Users/realor/Desktop/signatures/VALID_1.3.xml"));

      List<String> options = new ArrayList<>();
      options.add(PRESERVE_OPTION);
      DocumentValidation documentValidation = doc.validate(options);
      doc.writeDocument(new FileOutputStream("c:/Users/realor/Desktop/signatures/VALID_1.3_A.xml"));

      System.out.println("Document valid: " + documentValidation.isValid());
      List<SignatureValidation> signatureValidationList =
        documentValidation.getSignatureValidation();
      for (int i = 0; i < signatureValidationList.size(); i++)
      {
        SignatureValidation signatureValidation = signatureValidationList.get(i);
        System.out.println("Signature " + (i + 1) + "/" + signatureValidationList.size() + ":");
        System.out.println(" signatureId: " + signatureValidation.getSignatureId());
        System.out.println(" format: " + signatureValidation.getFormat());
        System.out.println(" signer: " + signatureValidation.getSigner());
        System.out.println(" signingDateTime: " + signatureValidation.getSigningDateTime());
        System.out.println(" expirationDateTime: " + signatureValidation.getExpirationDateTime());
        System.out.println(" valid: " + signatureValidation.isValid());
        for (ValidationDetail detail : signatureValidation.getValidationDetail())
        {
          System.out.println(" -" + detail.getCode() + ": " + detail.getMessage());
        }
      }
    }
    catch (Exception ex)
    {
      ex.printStackTrace();
    }
  }
}
